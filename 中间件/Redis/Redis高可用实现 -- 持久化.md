## 前言
--- 高可用
在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务。
在Redis语境中，高可用除了保证服务器正常服务之外，还需要考虑数据容量的拓展、数据安全不丢失等。

在Redis中，实现高可用用的技术主要包括 `持久化`、`复制(读写分离)`、`哨兵`和`集群`。

下面分别介绍它么的作用(解决什么样的问题)以及如何实现.

---


## 1. 持久化
持久化是最简单的高可用方法，有时甚至不被归为高可用的手段。主要作用是数据备份，即将数据存储到硬盘，保证数据不会因进程的退出而丢失。

### <1> Redis持久化概述
持久化功能：
	Redis是内存数据库，数据都是存储在内存中的，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到磁盘。当下次Redis重启时，
利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。

Redis持久化实现分为 RDB持久化 和 AOF持久化，前者将当前数据保存到磁盘，后者则是将每次执行的写命令以append追加的形式保存到磁盘(类似于MySQL的Binlog)。
由于AOF持久化的实时性更好，即当进程意外退出时，丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。


### <2> RDB持久化
RDB持久化是将当前进程中的数据生成快照保存到磁盘(因此也被称作快照持久化)，保存的文件后缀是.rdb；当Redis重新启动时，可以读取快照文件恢复数据。

#### 触发条件：

. save m n
m秒内至少发生了n次写命令。（是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的）

. bgsave：
在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点；
执行shutdown命令时，自动执行rdb持久化，

主进程会fork出一个子进程用来执行RDB持久化过程
bgsave的实现过程：
 .1 Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。
 .2 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令；
 .3 父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令；
 .4 子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换；
 .5 子进程发送信号给父进程表示完成，父进程更新统计信息。



RDB文件是经过压缩的二进制文件.
Redis默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启；
需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行。

#### 启动时加载
RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。
但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。
服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。
Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。



#### RDB常用配置
下面是RDB常用的配置项，以及默认值：
save m n：bgsave自动触发的条件；如果没有save m n配置，相当于自动的RDB持久化关闭，不过此时仍可以通过其他方式触发。

stop-writes-on-bgsave-error yes：当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no。

rdbcompression yes：是否开启RDB文件压缩。

rdbchecksum yes：是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现。

dbfilename dump.rdb：RDB文件名。

dir ./：RDB文件和AOF文件所在目录。





### <3> AOF持久化
RDB持久化是将数据写进文件，而AOF持久化(即Append Only File持久化)，则是将Redis执行的每次命令记录到单独的日志
文件中(类似于MySQL的Binlog);当Redis重启时再次执行AOF文件中的命令来恢复数据。

与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。


Redis服务器默认开启RDB，关闭AOF；
要开启AOF需要在配置文件中进行配置：appendonly yes


由于需要记录Redis的每条写命令，因此AOF不需要触发，AOF的执行流程如下：
.1 命令追加(append): 将Redis的写命令追加到缓冲区aof_buf
.2 文件写入(write) 和 文件同步(sync): 根据不同的同步策略将aof_buf中的内容同步到磁盘
.3 文件重写(rewrite): 定期重写AOF文件，达到文件压缩的目的


#### AOF常用配置：
appendonly no：是否开启AOF

appendfilename "appendonly.aof"：AOF文件名

dir ./：RDB文件和AOF文件所在目录

appendfsync everysec：fsync持久化策略

no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡

auto-aof-rewrite-percentage 100：文件重写触发条件之一

auto-aof-rewrite-min-size 64mb：文件重写触发提交之一

aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件




### <4> RDB和AOF的优缺点
RDB持久化
优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。

缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。



AOF持久化
与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。




### <5> 持久化策略选择
在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。



在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用RDB或AOF的一种，或同时开启RDB和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。



下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。



1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。



2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。



3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。



在这种情况下，一种可行的做法是：



master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好；

slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。



这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：



master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。

master误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵（关于哨兵后面会有文章介绍）进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。



4）异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。



例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。



一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其它条件来确定，但最好不要低于一天一次。


### <6> 总结
本文主要内容可以总结如下：

持久化在Redis高可用中的作用：数据备份，与主从复制相比强调的是由内存到硬盘的备份。

RDB持久化：将数据快照备份到硬盘；介绍了其触发条件（包括手动出发和自动触发）、执行流程、RDB文件等，特别需要注意的是文件保存操作由fork出的子进程来进行。

AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog），介绍了其开启方法、执行流程等，特别需要注意的是文件同步策略的选择（everysec）、文件重写的流程。

一些现实的问题：包括如何选择持久化策略，以及需要注意的fork阻塞、AOF追加阻塞等。


---
































## 2. 复制
复制是实现Redis高可用的基础，哨兵和集群都是在复制的基础上实现高可用的。复制主要实现了数据的多机备份以及对`读操作`的负载均衡和简单的`故障恢复`。
缺陷是故障无法自动化，`写操作`无法负载均衡，`存储能力`受到单机的限制。











## 3. 哨兵
在复制的基础上，哨兵实现了自动化的故障恢复。
缺陷是`写操作`无法负载均衡，存储能力受到单机的限制。





## 4. 集群
通过集群，Redis解决了`写操作`无法负载均衡以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。